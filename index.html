<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Torneo Tennis – Gironi</title>
<style>
 body {font-family: Arial, sans-serif; padding: 20px; background:#FFE5B4;} 
 h2 {margin-top:40px;}
 table {border-collapse: collapse; margin-bottom:20px; width:100%;}
 th, td {border:1px solid #999; padding:6px; text-align:center;}
 th {background:#FFD580;}
 input[type="text"]{width:120px;}
 .match-row{margin-bottom:8px;}
 .qualified {background:#b6fcb6 !important; font-weight:bold;}
</style>
</head>
<body>
<h1>Torneo Tennis – Fase a Gironi</h1>
<p>Inserisci i punteggi set per set. Lo script calcola automaticamente vincitore, punti e set.</p>

<p><strong>⚠️ ATTENZIONE:</strong> Per aggiornare i risultati permanenti su GitHub Pages, modifica direttamente i valori qui sotto dentro l’oggetto <code>results</code> e ricarica il file su GitHub.</p>

<div id="app"></div>

<script>
const groups = {
 A:["Andrea Calabrese","Mario Verrocchi","Francesco Giallonardo","Fabio Di Marcantonio"],
 B:["Emanuele Caputo","Fabrizio Giammarco","Lorenzo De Nuzzo","Massimiliano Giovannelli"],
 C:["Cristian Cianchetta","Matteo Ciampa","Ennio Ferzoco","Nicolo Grasso"],
 D:["Claudio Giammarco","Stefano Restaino","Fabio Formichetti","Andrea Marino"]
};

/* =====================================
   MODIFICA I RISULTATI QUI
   Usa il formato "6-3 6-4 10-8"
   Usa "-" per match ancora da giocare
===================================== */
let results = {
  "Andrea Calabrese|Mario Verrocchi":"-",
  "Andrea Calabrese|Francesco Giallonardo":"-",
  "Andrea Calabrese|Fabio Di Marcantonio":"6-4 6-2",
  "Mario Verrocchi|Francesco Giallonardo":"6-3 6-7 6-10",
  "Mario Verrocchi|Fabio Di Marcantonio":"-",
  "Francesco Giallonardo|Fabio Di Marcantonio":"-",

  "Emanuele Caputo|Fabrizio Giammarco":"-",
  "Emanuele Caputo|Lorenzo De Nuzzo":"6-3 6-2",
  "Emanuele Caputo|Massimiliano Giovannelli":"-",
  "Fabrizio Giammarco|Lorenzo De Nuzzo":"2-6 4-6",
  "Fabrizio Giammarco|Massimiliano Giovannelli":"6-0 6-3",
  "Lorenzo De Nuzzo|Massimiliano Giovannelli":"-",

  "Cristian Cianchetta|Matteo Ciampa":"-",
  "Cristian Cianchetta|Ennio Ferzoco":"-",
  "Cristian Cianchetta|Nicolo Grasso":"6-2 7-5",
  "Matteo Ciampa|Ennio Ferzoco":"4-6 6-4 10-3",
  "Matteo Ciampa|Nicolo Grasso":"-",
  "Ennio Ferzoco|Nicolo Grasso":"-",

  "Claudio Giammarco|Stefano Restaino":"-",
  "Claudio Giammarco|Fabio Formichetti":"-",
  "Claudio Giammarco|Andrea Marino":"6-2 6-2",
  "Stefano Restaino|Fabio Formichetti":"6-4 7-5",
  "Stefano Restaino|Andrea Marino":"-",
  "Fabio Formichetti|Andrea Marino":"-"
};

function parseScore(score){
  if(score.trim() === "-" || score.trim() === "") 
    return {winner:null, aSets:0, bSets:0, aGames:0, bGames:0};
  let sets = score.trim().split(/\s+/);
  let aSets=0,bSets=0,aGames=0,bGames=0;
  for (let s of sets){
    const [ga,gb]=s.split('-').map(Number);
    if(isNaN(ga)||isNaN(gb)) continue;
    if(ga>gb) aSets++; else bSets++;
    aGames+=ga; bGames+=gb;
  }
  let winner = aSets>bSets?0:1;
  return {winner,aSets,bSets,aGames,bGames};
}

// confronto diretto tra due giocatori
function headToHead(p1,p2){
  const key1 = `${p1}|${p2}`;
  const key2 = `${p2}|${p1}`;
  const match = results[key1] || results[key2];
  if(!match || match==="-") return null;
  const parsed = parseScore(match);
  if(parsed.winner===null) return null;
  return parsed.winner===0 ? p1 : p2;
}

// calcola classifica avulsa per un gruppo di giocatori in parità
function miniClassifica(players, stats){
  let subStats = {};
  players.forEach(p=>subStats[p]={points:0,setW:0,setL:0,gameW:0,gameL:0});
  for(const k in results){
    const [p1,p2]=k.split("|");
    if(!players.includes(p1) || !players.includes(p2)) continue;
    const r=parseScore(results[k]);
    if(r.winner===null) continue;
    subStats[p1].setW+=r.aSets; subStats[p1].setL+=r.bSets;
    subStats[p2].setW+=r.bSets; subStats[p2].setL+=r.aSets;
    subStats[p1].gameW+=r.aGames; subStats[p1].gameL+=r.bGames;
    subStats[p2].gameW+=r.bGames; subStats[p2].gameL+=r.aGames;
    if(r.winner===0){
      const pts=(r.bSets===0)?3:2;
      subStats[p1].points+=pts;
      subStats[p2].points+=(r.bSets===0)?0:1;
    } else {
      const pts=(r.aSets===0)?3:2;
      subStats[p2].points+=pts;
      subStats[p1].points+=(r.aSets===0)?0:1;
    }
  }

  return Object.entries(subStats).sort((a,b)=>{
    if(b[1].points!==a[1].points) return b[1].points-a[1].points;
    const diffSetA=a[1].setW-a[1].setL;
    const diffSetB=b[1].setW-b[1].setL;
    if(diffSetB!==diffSetA) return diffSetB-diffSetA;
    const diffGameA=a[1].gameW-a[1].gameL;
    const diffGameB=b[1].gameW-b[1].gameL;
    return diffGameB-diffGameA;
  }).map(e=>e[0]);
}

function render(){
  const app=document.getElementById('app');
  app.innerHTML="";
  for(const g in groups){
    const players=groups[g];
    app.innerHTML+=`<h2>Girone ${g}</h2>`;
    
    // Input match
    for(let i=0;i<players.length;i++){
      for(let j=i+1;j<players.length;j++){
        const key = `${players[i]}|${players[j]}`;
        const val = results[key] || "-";
        app.innerHTML+=`
          <div class="match-row">
            ${players[i]} vs ${players[j]}:
            <input type="text" data-key="${key}" value="${val}">
          </div>`;
      }
    }

    // Stats globali
    let stats={};
    players.forEach(p=>stats[p]={points:0,played:0,setW:0,setL:0,gameW:0,gameL:0});
    for(const k in results){
      const [p1,p2]=k.split("|");
      if(!stats[p1]||!stats[p2]) continue;
      const r=parseScore(results[k]);
      if(r.winner === null) continue;
      stats[p1].played++; stats[p2].played++;
      stats[p1].setW+=r.aSets; stats[p1].setL+=r.bSets;
      stats[p2].setW+=r.bSets; stats[p2].setL+=r.aSets;
      stats[p1].gameW+=r.aGames; stats[p1].gameL+=r.bGames;
      stats[p2].gameW+=r.bGames; stats[p2].gameL+=r.aGames;
      if(r.winner===0){
        const pts = (r.bSets===0)?3:2;
        stats[p1].points+=pts;
        stats[p2].points+=(r.bSets===0)?0:1;
      } else {
        const pts = (r.aSets===0)?3:2;
        stats[p2].points+=pts;
        stats[p1].points+=(r.aSets===0)?0:1;
      }
    }

    // Ordinamento con gestione parità
    let ordered = Object.entries(stats);
    ordered.sort((a,b)=> b[1].points - a[1].points);

    // Risolvi parità
    let finalOrder=[];
    let i=0;
    while(i<ordered.length){
      const pts=ordered[i][1].points;
      let tied=[ordered[i][0]];
      let j=i+1;
      while(j<ordered.length && ordered[j][1].points===pts){
        tied.push(ordered[j][0]);
        j++;
      }
      if(tied.length===1){
        finalOrder.push(ordered[i][0]);
      } else if(tied.length===2){
        const h2h=headToHead(tied[0],tied[1]);
        if(h2h){
          if(h2h===tied[0]) finalOrder.push(tied[0],tied[1]);
          else finalOrder.push(tied[1],tied[0]);
        } else {
          // fallback: differenza set/giochi globali
          tied.sort((x,y)=>{
            const diffSetX=stats[x].setW-stats[x].setL;
            const diffSetY=stats[y].setW-stats[y].setL;
            if(diffSetY!==diffSetX) return diffSetY-diffSetX;
            const diffGameX=stats[x].gameW-stats[x].gameL;
            const diffGameY=stats[y].gameW-stats[y].gameL;
            return diffGameY-diffGameX;
          });
          finalOrder.push(...tied);
        }
      } else {
        // classifica avulsa
        const avulsa=miniClassifica(tied,stats);
        finalOrder.push(...avulsa);
      }
      i=j;
    }

    // Tabella
    let table=`<table><tr>
      <th>Giocatore</th><th>Punti</th><th>Partite</th><th>Set W-L</th>
    </tr>`;
    finalOrder.forEach((p,idx)=>{
      const s=stats[p];
      table+=`<tr class="${idx<2?'qualified':''}">
        <td>${p}</td>
        <td>${s.points}</td>
        <td>${s.played}</td>
        <td>${s.setW}-${s.setL}</td>
      </tr>`;
    });
    table+="</table>";
    app.innerHTML+=table;
  }

  // Gestione input dinamico
  document.querySelectorAll('input[data-key]').forEach(inp=>{
    inp.onchange=e=>{
      const k=e.target.dataset.key;
      if(e.target.value.trim()==="") results[k]="-";
      else results[k]=e.target.value.trim();
      render();
    };
  });
}

render();
</script>
</body>
</html>

